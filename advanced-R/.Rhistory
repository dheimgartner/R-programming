j <- function(x) {
y <- 2
function() {
c(x, y)
}
}
k <- j(1)
k()
rm(j, k)
# Environments ----
# http://adv-r.had.co.nz/Environments.html#binding
j <- function() {
if (!exists("a")) {
a <- 1
} else {
a <- a + 1
}
a
}
j()
j()
a <- 100
j()
j()
rm(list(a, j))
rm(a, j)
clearPushBack()
?codetools
codetools::findGlobals()
codetools::findGlobals(dplyr::mutate)
?runif
?replicate
# Environments ----
# http://adv-r.had.co.nz/Environments.html#binding
`(` <- function(e1) {
if (is.numeric(e1) && runif(1) < 0.1) {
e1 + 1
} else {
e1
}
}
replicate(50, c(1, 2))
i <- 0
while (i < 50) {
print(c(1))
i <- i + 1
}
?(
?`(`
(1)
(1)
i <- 0
while (i < 50) {
print((1))
i <- i + 1
}
i <- 0
while (i < 100) {
print((1))
i <- i + 1
}
i <- 0
while (i < 100) {
print(c(1))
i <- i + 1
}
?`c`
rm("(")
rm(i)
# Environments ----
# http://adv-r.had.co.nz/Environments.html#binding
f <- function(x) {
f <- function(x) {
f <- function(x) {
x ^ 2
}
f(x) + 1
}
f(x) * 2
}
f(10)
rm(f)
?`<<-`
# Environments ----
# http://adv-r.had.co.nz/Environments.html#binding
library(pryr)
setClass("Person",
slots = list(name = "character", age = "numeric"))
new.Person()
environment()
search()
# access any env
as.environment("package:stats")
environment()
?as.environment
# access any env
as.environment("package:stats")$
# access any env
list(as.environment("package:stats"))
# list the bindings
ls(package:stats)
# create new env
e <- new.env()
parent.env(e)
# easiest way to modify bindings -> treat like list
e$a <- "hello"
e$b <- "world"
View(e)
ls(e)
e$.a <- "hidden"
ls(e)
ls(e, all.names = T)
c <- "global_env"
e$c
get("c", envir = e)
rm(".a", envir = e)
ls(e, all.names = T)
exists("c", envir = e)
exists("c", envir = e, inherits = F)
# Recursing over environments ----
where("e")
# Recursing over environments ----
where("c")
where("mean")
?stop
env
parent.frame
parent.frame()
# Enclosing environments --
y <- 1
f <- function(x) x + y
environment(f)
# Binding environments --
# For the function f the binding env is the same as the enclosing env
# however we can assign a different env
e <- new.env()
e$g <- function() 1
environment(g)
environment(e$g)
where(g)
where("g")
e$g <- function() 1
where("g")
View(e)
environment(sd)
environment(g)
where(sd)
where("sd")
environment(sd)
g()
e$g()
e::g()
e$g <- function() y
environment(e$g)
e$g()
environment(g)
environment(e$g)
environment(e$g) <- e
e$g()
environment(e$g)
e$y <- 2
e$g()
rm(y)
plus <- function(x) {
function(y) x + y
}
plus(1)
plus_one <- plus(1)
plus_one(2)
plus_one <- plus(1) # the enclosing env of plus_one is the execution env of plus() where x is bound to the value 1
plus_one(3)
plus_one(3) %>% plus_one()
plus_one(plus_one(3))
h <- function() {
x <- 10
function() {
x
}
}
i <- h()
x <- 20
i()
?parent.frame
parent.frame()
# Calling environments --
# the unfortunately named parent.frame() returns the environment where the function was called
f <- function() {parent.frame()}
f()
e$f <- f
e$f()
View(e)
rm(f)
e$f()
# Calling environments --
# the unfortunately named parent.frame() returns the environment where the function was called
rm(f, envir = e)
View(e)
?environment
library(pryr)
# S3 ----
# check if object is S3
df <- data.frame(x = 1:10, y = letters[1:10])
otype(df)
otype(df$x)  # numeric vector is "base"
otype(df$y)  # factor is "S3"
class(df$y)
typeof(df$y)
# Some S3 generics (like [, sum(), etc.) don't call UseMethod() because they are
# implemented in C. They are called internal generics and documented in ?"internal generic".
# ftype() knows about these special cases too.
?"internal generic"
# Defining classes and creating objects --
foo <- structure(list(), class = "foo")
setMethod("phone_call",
c(x = "Person", y = "Person"),  # signature
function(x, y) print(paste0(x@name, " calls ", y@name)))
# Creating new methods and generics --
# good idea to use constructor function with same name as class (then use constructor instead of new())
# if you create generics from scratch use standardGeneric() which is the S4 equivalent to UseMethod()
setGeneric("phone_call",
def = function(x, y) standardGeneric("phone_call"))
class(print)
ex <- "hello"
class(ex)
class(ex) <- "my_char"
class(ex)
mode(ex)
print(ex)
print.my_char <- function(x) print(paste0("---", x, "---"))
print(ex)
"print.my_char" %in% methods(print)
`[.my_char` <- function(x, i) {
if (i > length(x)) stop("Index out of bound!")
strsplit(x, "")[[1]][i]
}
ex[1]
ex[10]
"hello"[1]
"hello"[2]
"hello"[3]
c("hello", "world") -> test
class(test)
mode(test)
is.vector(test)
is.vector("hello")
length("hello")
length("hello", "world")
test <- (1, 2)
tuple(1,2 )
library(pryr)
# S3 ----
# check if object is S3
df <- data.frame(x = 1:10, y = letters[1:10])
otype(df)
otype(df$x)  # numeric vector is "base"
otype(df$y)  # factor is "S3"
class(df$y)
typeof(df$y)
# Some S3 generics (like [, sum(), etc.) don't call UseMethod() because they are
# implemented in C. They are called internal generics and documented in ?"internal generic".
# ftype() knows about these special cases too.
?"internal generic"
df
df[[x]]
df[["x"]]
df$x
``
`[[`.data.frame
`[`.data.frame
`[[.data.frame`
debugonce(`[[.data.frame`)
df[["y"]]
("hello"; "world")
("hello" "world")
("hello")
(x <- 1)
(x <- 1, y <- 2)
(x <- 1 y <- 2)
(x <- 1; y <- 2)
# Defining classes and creating objects --
foo <- structure(list(), class = "foo")
foo <- list()
class(foo) <- "foo"
# most S3 classes provide a constructor function
foo <- function(x) {
if (!is.numeric(x)) stop("X must be numeric")
structure(list(x), class = "foo")
}
foo("hello")
foo(7)
foo(8, 9)
foo((8, 9))
# generic.class
f.a <- function(x) "Hello from method describing behaviour if f is applied on class a"
f.default <- function(x) "Unknown class"
a <- structure(list(), class = "a")
f(a)
# Creating new methods and generics --
# To add a new generic, create a function that calls UseMethod()
f <- function(x) UseMethod("f")  # takes two arguments: the name of the generic function, and the argument to use for method dispatch
ftype(f)
f(a)
class(factor)
test <- factor(x = c("Daniel", "Heimgartner"))
test
levels(test)
labels(test)
test <- factor(x = c("Daniel", "Heimgartner"), levels = c(1, 2))
test
test <- factor(x = c("Daniel", "Heimgartner"), labels = c(1, 2))
test
test
test <- factor(x = c("Daniel", "Heimgartner"), labels = c(1, 2))
test
test[1]
rm(list = ls())
test <- factor(x = c("Daniel", "Heimgartner"), labels = c(1, 2))
ttest
test
?factor
setClass("Person",
slots = list(name = "character", age = "numeric"))
setClass("Employee",
slots = list(boss = "Person"),  # in slots you can use S4 classes, S3 classes (setOldClass()) or implicit class or base type
contains = "Person")  # contains ~ inherits
alice <- new("Person", name = "Alice", age = 40)
john <- new("Employee", name = "John", age = 20, boss = alice)
alice@age
slot(john, "boss")
# Creating new methods and generics --
# good idea to use constructor function with same name as class (then use constructor instead of new())
# if you create generics from scratch use standardGeneric() which is the S4 equivalent to UseMethod()
setGeneric("phone_call",
def = function(x, y) standardGeneric("phone_call"))
setMethod("phone_call",
c(x = "Person", y = "Person"),  # signature
function(x, y) print(paste0(x@name, " calls ", y@name)))
setMethod("phone_call",
c(x = "character", y = "character"),
function(x, y) print(paste0(x, " --> ", y)))
phone_call(alice, john)  # since john is also a Person...
phone_call("Alice", "John")
selectMethod("phone_call", list("Person", "Person"))
otype(alice)
class?person
class?factor
is(alice)
str(alice)
isS4(alice)
otype(phone_call)
ftype(phone_call)
is(phone_call)
str(phone_call)
isS4(phone_call)
?setClass
?setMethod
setClass("track", slots = c(x ="numeric", y="numeric"))
method.skeleton("show", "track")
library(R6)
package_version("R6")
package_version(R6)
packageVersion("R6")
install.packages("R6")
install.packages("R6")
packageVersion("R6")

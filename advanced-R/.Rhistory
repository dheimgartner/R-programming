j <- function(x) {
y <- 2
function() {
c(x, y)
}
}
k <- j(1)
k()
rm(j, k)
# Environments ----
# http://adv-r.had.co.nz/Environments.html#binding
j <- function() {
if (!exists("a")) {
a <- 1
} else {
a <- a + 1
}
a
}
j()
j()
a <- 100
j()
j()
rm(list(a, j))
rm(a, j)
clearPushBack()
?codetools
codetools::findGlobals()
codetools::findGlobals(dplyr::mutate)
?runif
?replicate
# Environments ----
# http://adv-r.had.co.nz/Environments.html#binding
`(` <- function(e1) {
if (is.numeric(e1) && runif(1) < 0.1) {
e1 + 1
} else {
e1
}
}
replicate(50, c(1, 2))
i <- 0
while (i < 50) {
print(c(1))
i <- i + 1
}
?(
?`(`
(1)
(1)
i <- 0
while (i < 50) {
print((1))
i <- i + 1
}
i <- 0
while (i < 100) {
print((1))
i <- i + 1
}
i <- 0
while (i < 100) {
print(c(1))
i <- i + 1
}
?`c`
rm("(")
rm(i)
# Environments ----
# http://adv-r.had.co.nz/Environments.html#binding
f <- function(x) {
f <- function(x) {
f <- function(x) {
x ^ 2
}
f(x) + 1
}
f(x) * 2
}
f(10)
rm(f)
?`<<-`
# Environments ----
# http://adv-r.had.co.nz/Environments.html#binding
library(pryr)
setClass("Person",
slots = list(name = "character", age = "numeric"))
new.Person()
environment()
search()
# access any env
as.environment("package:stats")
environment()
?as.environment
# access any env
as.environment("package:stats")$
# access any env
list(as.environment("package:stats"))
# list the bindings
ls(package:stats)
# create new env
e <- new.env()
parent.env(e)
# easiest way to modify bindings -> treat like list
e$a <- "hello"
e$b <- "world"
View(e)
ls(e)
e$.a <- "hidden"
ls(e)
ls(e, all.names = T)
c <- "global_env"
e$c
get("c", envir = e)
rm(".a", envir = e)
ls(e, all.names = T)
exists("c", envir = e)
exists("c", envir = e, inherits = F)
# Recursing over environments ----
where("e")
# Recursing over environments ----
where("c")
where("mean")
?stop
env
parent.frame
parent.frame()
# Enclosing environments --
y <- 1
f <- function(x) x + y
environment(f)
# Binding environments --
# For the function f the binding env is the same as the enclosing env
# however we can assign a different env
e <- new.env()
e$g <- function() 1
environment(g)
environment(e$g)
where(g)
where("g")
e$g <- function() 1
where("g")
View(e)
environment(sd)
environment(g)
where(sd)
where("sd")
environment(sd)
g()
e$g()
e::g()
e$g <- function() y
environment(e$g)
e$g()
environment(g)
environment(e$g)
environment(e$g) <- e
e$g()
environment(e$g)
e$y <- 2
e$g()
rm(y)
plus <- function(x) {
function(y) x + y
}
plus(1)
plus_one <- plus(1)
plus_one(2)
plus_one <- plus(1) # the enclosing env of plus_one is the execution env of plus() where x is bound to the value 1
plus_one(3)
plus_one(3) %>% plus_one()
plus_one(plus_one(3))
h <- function() {
x <- 10
function() {
x
}
}
i <- h()
x <- 20
i()
?parent.frame
parent.frame()
# Calling environments --
# the unfortunately named parent.frame() returns the environment where the function was called
f <- function() {parent.frame()}
f()
e$f <- f
e$f()
View(e)
rm(f)
e$f()
# Calling environments --
# the unfortunately named parent.frame() returns the environment where the function was called
rm(f, envir = e)
View(e)
?environment
library(pryr)
# S3 ----
# check if object is S3
df <- data.frame(x = 1:10, y = letters[1:10])
otype(df)
otype(df$x)  # numeric vector is "base"
otype(df$y)  # factor is "S3"
class(df$y)
typeof(df$y)
# Some S3 generics (like [, sum(), etc.) don't call UseMethod() because they are
# implemented in C. They are called internal generics and documented in ?"internal generic".
# ftype() knows about these special cases too.
?"internal generic"
# Defining classes and creating objects --
foo <- structure(list(), class = "foo")
setMethod("phone_call",
c(x = "Person", y = "Person"),  # signature
function(x, y) print(paste0(x@name, " calls ", y@name)))
# Creating new methods and generics --
# good idea to use constructor function with same name as class (then use constructor instead of new())
# if you create generics from scratch use standardGeneric() which is the S4 equivalent to UseMethod()
setGeneric("phone_call",
def = function(x, y) standardGeneric("phone_call"))
